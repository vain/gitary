#!/bin/bash

_edit()
{
    basedir=$(dirname -- "$1")
    mkdir -p -- "$basedir" || { echo "Could not create '$basedir'" >&2; return 1; }

    $editor "$1"

    clean_empty
    commit
}

_list()
{
    # Don't quote $1 here because it could be a '*'.
    for i in $1/*/"$entry_fname"
    do
        editable=${i%/*}
        echo "$editable  $(head -n 1 -- "$i")"
    done
}

list_all()
{
    _list '*'
}

list_today()
{
    _list "$(date +%F)"
}

blob_dir()
{
    # We don't provide any file management operations. This is up to the
    # user and his tools. Instead, we provide this shortcut to print the
    # blob directory of the last entry today or of any given entry.
    if [[ -z "$1" ]]
    then
        t=$(date +%F)
        last=$(printf '%s\n' "$t"/*/"$entry_fname" | tail -n 1)
        if [[ -z "$last" ]]
        then
            echo "Please create an entry for today first" >&2
            return 1
        fi
        echo "${last%/*}/$blobs_fname"
    else
        echo "$1/$blobs_fname"
    fi
}

clean_empty()
{
    # Remove files with a size of 0, 1 or 2 bytes, i.e. "completely
    # empty", "only a UNIX newline", or "only a DOS newline".
    #
    # Note that we can't use find's "-delete" because it turns on
    # "-depth" which conflicts with "-prune".
    #
    # We use a max depth of 3 to not touch any blob *files*. If the blob
    # directory itself is empty, though, it will be removed.
    find -H . -maxdepth 3 \
        -type d -name .git -prune -o \
        -type f -size -3c \
        -printf "Cleaning up empty file '%P'\n" -exec rm {} +

    find -H . -maxdepth 3 \
        -type d -name .git -prune -o \
        -type d -empty \
        -printf "Cleaning up empty directory '%P'\n" -exec rmdir {} +
}

commit()
{
    git add -A .
    git commit -a -m "Auto-Commit by gitary on $HOSTNAME"
}

continue_today()
{
    t=$(date +%F)
    last=$(printf '%s\n' "$t"/*/"$entry_fname" | tail -n 1)
    if [[ -z "$last" ]]
    then
        echo "Please create an entry for today first" >&2
        return 1
    fi

    _edit "$last"
}

edit_entry()
{
    if [[ -z "$1" ]]
    then
        echo "Error: edit_entry() needs an argument (e.g., '2009-08-01/04')" >&2
        return 1
    fi

    e=$1
    [[ "$e" == *"$entry_fname" ]] || e="$e/$entry_fname"

    if [[ ! -f "$e" ]]
    then
        echo "Trying to edit '$e', which does not exist" >&2
        return 1
    fi

    _edit "$e"
}

check_and_cd_to_datadir()
{
    if ! type git >/dev/null 2>&1
    then
        echo "Command 'git' not found" >&2
        return 1
    fi

    if ! cd -- "$datadir" >/dev/null 2>&1 || ! git status >/dev/null 2>&1
    then
        echo "'$datadir' is not a Git repository, please initialize it" >&2
        return 1
    fi
}

new_today()
{
    # Directory names go like '2016-08-21/d4/', i.e. the current date
    # followed by a hex representation of an 8 bit integer. This means
    # you can create a total of 256 entries per day, which should be
    # more than enough for a single person. :-)
    #
    # We pad the number with a leading zero, if necessary, which means
    # that we get an implicit sorting order and don't have to call
    # "sort" ourselves.
    day=$(date +%F)
    next='00'
    while [[ -f "$day"/"$next"/"$entry_fname" ]]
    do
        next=$((16#$next))
        (( next++ ))
        printf -v next '%02x' "$next"
    done

    if [[ "${#next}" -gt 2 ]]
    then
        echo "Maximum number of entries per day reached" >&2
        return 1
    fi

    _edit "$day/$next/$entry_fname"
}

search_bodies()
{
    grep -niHC 5 --color=always "$1" -- */*/"$entry_fname" | $pager
}

search_tags()
{
    grep -niHC 5 --color=always "^tags: .*$1" -- */*/"$entry_fname" | $pager
}

usage()
{
    echo "Unknown option, please refer to the manpage" >&2
}


default_prefix=${XDG_DATA_HOME:-$HOME/.local/share}
datadir=${GITARY_DATA:-$default_prefix/gitary}
editor=${EDITOR:-vim}
pager=${PAGER:-less}
blobs_fname=blobs
entry_fname=entry${GITARY_FILE_EXTENSION:-.md}

# We rely on "ASCIIbetical" sorting order.
export LC_COLLATE=C

shopt -s nullglob

check_and_cd_to_datadir || exit 1

if [[ -z "$1" ]]
then
    list_today
    exit
fi

opt=${1##*-}
case "$opt" in
    a|all)       list_all            ;;
    b|blob)      blob_dir "$2"       ;;
    c|continue)  continue_today      ;;
    e|edit)      edit_entry "$2"     ;;
    n|new)       new_today           ;;
    p|path)      pwd                 ;;
    s|search)    search_bodies "$2"  ;;
    t|tags)      search_tags "$2"    ;;
    *)           usage               ;;
esac
