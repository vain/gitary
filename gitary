#!/bin/bash

_edit()
{
    basedir=$(dirname -- "$1")
    mkdir -p -- "$basedir" || { echo "Could not create '$basedir'" >&2; return 1; }

    $editor "$1"

    clean_empty
    commit
}

_list()
{
    # Don't quote $1 here because it could be a '*'.
    for i in $1/*/"$entry_fname"
    do
        editable=${i%/*}
        echo "$editable  $(head -n 1 -- "$i")"
    done
}

list_all()
{
    _list '*'
}

list_today()
{
    _list "$(date +%F)"
}

blob_dir()
{
    # We don't provide any file management operations. This is up to the
    # user and his tools. Instead, we provide this shortcut to print the
    # blob directory of the last entry today or of any given entry.
    if [[ -z "$1" ]]
    then
        t=$(date +%F)
        last=$(printf '%s\n' "$t"/*/"$entry_fname" | tail -n 1)
        if [[ -z "$last" ]]
        then
            echo "Please create an entry for today first" >&2
            return 1
        fi
        echo "${last%/*}/$blobs_fname"
    else
        echo "$1/$blobs_fname"
    fi
}

clean_empty()
{
    if [[ "$1" != yes ]]
    then
        # Let's consider the following scenario:
        #
        # The user has started gitary and began writing an entry. It
        # took him quite a while, let's say "three hours", but in the
        # end, he decided to delete everything he wrote and quit the
        # editor.
        #
        # This leaves us with an empty "entry.md". If we were to clean
        # up that file, there might be some now empty parent directories
        # which can also be cleaned up. *This* is why this function
        # exists in the first place: We want to detect if the user has
        # aborted writing and then clean up unused files/directories.
        #
        # I speculate this is a common scenario.
        #
        # On the other hand, under what circumstances could we find
        # empty files/directories that have *not been touched* for quite
        # a while? I speculate that this is very rare.
        #
        # This means that when traversing the repo and looking for files
        # to delete, we can prune any "old" directories.
        optimization='-type d -mtime +1 -prune -o'
    else
        # Since the optimization above can indeed leave some files
        # behind, the user can optionally run a full clean up process
        # (which might take quite a while, depending on the size of the
        # repo and the user's hardware).
        optimization=''
    fi

    # Remove files with a size of 0, 1 or 2 bytes, i.e. "completely
    # empty", "only a UNIX newline", or "only a DOS newline".
    #
    # Note that we can't use find's "-delete" because it turns on
    # "-depth" which conflicts with "-prune".
    #
    # We use a max depth of 3 to not touch any blob *files*. If the blob
    # directory itself is empty, though, it will be removed.
    find -H . -maxdepth 3 \
        -type d -name .git -prune -o \
        $optimization \
        -type f -size -3c \
        -printf "Cleaning up empty file '%P'\n" -exec rm {} +

    find -H . -maxdepth 3 \
        -type d -name .git -prune -o \
        $optimization \
        -type d -empty \
        -printf "Cleaning up empty directory '%P'\n" -exec rmdir {} +
}

commit()
{
    git add -A .
    git commit -a -m "Auto-Commit by gitary on $HOSTNAME"
}

continue_today()
{
    t=$(date +%F)
    last=$(printf '%s\n' "$t"/*/"$entry_fname" | tail -n 1)
    if [[ -z "$last" ]]
    then
        echo "Please create an entry for today first" >&2
        return 1
    fi

    _edit "$last"
}

edit_entry()
{
    if [[ -z "$1" ]]
    then
        echo "Error: edit_entry() needs an argument (e.g., '2009-08-01/04')" >&2
        return 1
    fi

    e=$1
    [[ "$e" == *"$entry_fname" ]] || e="$e/$entry_fname"

    if [[ ! -f "$e" ]]
    then
        echo "Trying to edit '$e', which does not exist" >&2
        return 1
    fi

    _edit "$e"
}

check_and_cd_to_datadir()
{
    if ! type git >/dev/null 2>&1
    then
        echo "Command 'git' not found" >&2
        return 1
    fi

    # "git status" can be very slow. We want to avoid it.
    #
    # If this is a Git repo with at least one commit, "git rev-parse
    # HEAD" returns 0 and does so very fast, independent of the repo's
    # size. If no commit has been made yet, then "HEAD" does not point
    # to a commit hash, so "rev-parse" fails. In that case, we try "git
    # status" which properly returns 0, even for "empty" repos.
    #
    # So, most of the time, "rev-parse" does the job. Only freshly
    # initialized repos need "git status".
    if ! cd -- "$datadir" >/dev/null 2>&1 ||
    {
        ! git rev-parse HEAD >/dev/null 2>&1 &&
        ! git status >/dev/null 2>&1
    }
    then
        echo "'$datadir' is not a Git repository, please initialize it" >&2
        return 1
    fi
}

new_today()
{
    day=$(date +%F)
    etime=$(date +%H-%M-%S)
    _edit "$day/$etime/$entry_fname"
}

search_bodies()
{
    grep -EniHC 5 --color=always "$1" -- */*/"$entry_fname" | $pager
}

search_tags()
{
    grep -EniHC 5 --color=always "^tags: ?.*$1" -- */*/"$entry_fname" | $pager
}

usage()
{
    echo "Unknown option, please refer to the manpage" >&2
}


default_prefix=${XDG_DATA_HOME:-$HOME/.local/share}
datadir=${GITARY_DATA:-$default_prefix/gitary}
editor=${EDITOR:-vim}
pager=${PAGER:-less}
blobs_fname=blobs
entry_fname=entry${GITARY_FILE_EXTENSION:-.md}

# We rely on "ASCIIbetical" sorting order.
export LC_COLLATE=C

shopt -s nullglob

check_and_cd_to_datadir || exit 1

if [[ -z "$1" ]]
then
    list_today
    exit
fi

opt=${1##*-}
case "$opt" in
    a|all)           list_all            ;;
    b|blob)          blob_dir "$2"       ;;
    c|continue)      continue_today      ;;
    e|edit)          edit_entry "$2"     ;;
    f|full-cleanup)  clean_empty yes     ;;
    n|new)           new_today           ;;
    p|path)          pwd                 ;;
    s|search)        search_bodies "$2"  ;;
    t|tags)          search_tags "$2"    ;;
    *)               usage               ;;
esac
